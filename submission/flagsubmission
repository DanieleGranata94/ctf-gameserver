#!/usr/bin/python3

import asyncore
import asynchat
import socket
import argparse
import logging
import datetime

import psycopg2

from ctf_gameserver.lib import flag

class FlagHandler(asynchat.async_chat):
    def __init__(self, sock, addr, dbconnection, conteststart, contestend, flagvalidity, tickduration):
        asynchat.async_chat.__init__(self, sock=sock)
        ip, port = addr
        self.team = int(ip.split('.')[2])
        self._addr = addr
        self.set_terminator(b"\n")
        self._logger = logging.getLogger("%13s %5d" % (ip, port))
        self._cursor = None
        self._dbconnection = dbconnection
        self.buffer = b''
        self._logger.info("Accepted connection from Team %s", self.team)
        self._banner()
        self._conteststart = conteststart
        self._contestend = contestend
        self._flagvalidity = flagvalidity
        self._tickduration = tickduration

    def _reply(self, message):
        self._logger.debug("-> %s" % message.decode('utf-8'))
        self.push(message + "\n")

    def _get_tick(self, timestamp):
        tick = ((timestamp - self._conteststart.timestamp()) / self._tickduration) - self._flagvalidity
        return int(tick + 0.2)

    def _handle_flag(self):
        if self.buffer == b'':
            self._reply(b"418 I'm a teapot!")
            return

        if self.buffer == b'666':
            self._reply(b"So this, then, was the kernel of the brute!")
            return

        now = datetime.datetime.now(tz=datetime.timezone.utc)
        if now < self._conteststart:
            self._reply(b"Contest didn't even start yet!")
            return

        if now > self._contestend:
            self._reply(b"Contest already over!")
            return

        try:
            curflag = self.buffer.decode('us-ascii')
        except UnicodeDecodeError as e:
            self._reply(u"Flags should be of the Format [-_a-zA-Z0-9]+"
                      .encode('utf-8'))
            return

        try:
            team, service, _, timestamp = flag.verify(curflag)
        except flag.InvalidFlagFormat:
            self._reply(b"Flag not recognized")
            return
        except flag.InvalidFlagMAC:
            self._reply(b"Not such Flag")
            return
        except flag.FlagExpired as e:
            self._reply((u"Flag expired since %.1f seconds" % e.args).encode('utf-8'))
            return

        print("teamcheck", repr(team), repr(self.team))
        if team == self.team:
            self._reply(b"Can't submit a flag for your own team")
            return

        try:
            count = self._store_capture(team, service, timestamp):
            if count > 1:
                self._reply((u"Flags should only be submitted once (this is %d for your team) subtracting penalty!" % count).encode('utf-8'))
            else:
                self._reply(u"Thank you for your submission!".encode('utf-8'))
        except psycopg2.DatabaseError as e:
            self._logger.warn("%s: %s", e.diag.secerity, e.diag.message_primary)
            self._logger.info(e.diag.internal_query)
            self._reply(u"Something went wrong with your submission!".encode('utf-8'))


    def _store_capture(self, team, service, timestamp):
        with self._dbconnection:
            with self._dbconnection.cursor() as cursor:
                tick = self._get_tick(timestamp)
                cursor.execute("""SELECT id FROM scoring_flag
                                  WHERE service_id = %s
                                    AND protecting_team_id = %s
                                    AND tick = %s""",
                               (service, team, tick))
                flag_id = cursor.fetchone()

                cursor.execute("""SELECT max(count) FROM scoring_capture
                                  WHERE flag_id = %s
                                    AND capturing_team_id = %s""",
                               (flag_id, self.team))
                count = cursor.fetchone()

                if count is None:
                    count = 1
                else:
                    count = count[0] + 1

                cursor.execute("""INSERT INTO scoring_captures
                                      (flag_id, capturing_team_id, timestamp, count)
                                  VALUES
                                      (%s, %s, now(), %s)""",
                               (flag_id, self.team, count))
                return count


    def _banner(self):
        self.push(u"FAUSTCTF Flagserver\n".encode('utf-8'))
        self.push(u"One flag per line please!\n".encode('utf-8'))


    def collect_incoming_data(self, data):
        self.buffer = self.buffer + data


    def found_terminator(self):
        self._logger.debug("<- '%s'", self.buffer.decode('utf-8'))
        self._handle_flag()
        self.buffer = b''



class FlagServer(asyncore.dispatcher):
    def __init__(self, host, port, *args):
        asyncore.dispatcher.__init__(self)
        self.create_socket(family=socket.AF_INET)
        self.set_reuse_addr()
        self.bind((host, port))
        self.listen(5)
        self._otherargs = args
        self._logger = logging.getLogger("server")

    def handle_accepted(self, sock, addr):
        self._logger.info('Incoming connection from %s', repr(addr))
        handler = FlagHandler(sock, addr, *self._otherargs)

def main():
    logging.basicConfig(format='%(asctime)s %(levelname)s(%(name)s): %(message)s',
                        datefmt='%m/%d/%Y %H:%M:%S')

    parser = argparse.ArgumentParser(description="Flag submission system")
    parser.add_argument('-v', '--loglevel', default='WARNING', type=str,
                        choices=['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'],
                        help='Loglevel')
    parser.add_argument('-l', '--listen', type=str, default="localhost",
                        help='address or hostname to listen on')
    parser.add_argument('-p', '--port', type=int, default="6666",
                        help="Port to listen on")
    parser.add_argument('--db', type=str, default="dbname=faustctf user=submission")
    args = parser.parse_args()

    numeric_level = getattr(logging, args.loglevel.upper())
    logging.getLogger().setLevel(numeric_level)

    logging.debug("connecting to database")
    dbconnection = psycopg2.connect(args.db)

    with dbconnection:
        with dbconnection.cursor() as cursor:
            global conteststart, flagvalidity, tickduration
            cursor.execute('''SELECT start, "end", valid_ticks, tick_duration
                              FROM scoring_gamecontrol''')
            conteststart, contestend, flagvalidity, tickduration = cursor.fetchone()

    logging.debug("Starting asyncore")
    server = FlagServer(args.listen, args.port, dbconnection, conteststart, contestend, flagvalidity, tickduration)
    try:
        import systemd.daemon
        systemd.daemon.notify("READY=1")
    except ImportError:
        pass
    asyncore.loop()

if __name__ == '__main__':
    main()
